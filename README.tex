% Created 2018-01-06 Sat 22:51
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Shubham Mahajan}
\date{\today}
\title{Structures And Pointers}
\hypersetup{
 pdfauthor={Shubham Mahajan},
 pdftitle={Structures And Pointers},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 25.2.2 (Org mode 9.1.4)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Basics of structures…}
\label{sec:org2c4f66a}

\subsection{Definition}
\label{sec:orga11cd07}

A structure simply is a collection of finite set of similar (heterogeneous)
collection of data elements under a single name.

\subsubsection{But what do we mean by that?}
\label{sec:org6ad2c07}

Consider a scenario where we want to maintain a College record of a student.
Now, let’s try to visualize the various variables we are going to deal with:

\begin{itemize}
\item student-Name
\item student-Email
\item student-Branch
\item student-Mobile
\item student-Year
\item student-Age
\item student-Gender
\item student-DOB
\item student-RollNo
\item student-Course
\item student-Father-Name
\item student-Mother–Name
\item student-Subjects
\item student-Marks
\item student-Percentage
\item student-Curr-Semester
\item student-Aggregate-Marks
\end{itemize}

and the list goes on…

\uline{\textbf{Phew!!! So much clutter in all these variables, very hard to keep track of each
one of them individually.}}

The best approach to follow in a programming environment is \textbf{“Divide
n’Conquer”}. Instead of dealing with all these variables at once, let’s try to
\textbf{divide them into groups}:

\begin{center}
\begin{tabular}{ll}
\hline
\uline{GROUP - A} & \textbf{student-Personal-Details}\\
\hline
 & - name\\
 & - age\\
 & - gender\\
 & - DOB\\
 & - email\\
 & - mobile\\
 & - father-Name\\
 & - mother-name\\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ll}
\hline
\uline{GROUP - B} & \textbf{student-College-Details}\\
 & - rollNo\\
 & - year\\
 & - branch\\
 & - course\\
 & - semester\\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ll}
\hline
\uline{GROUP - C} & \textbf{student-Academic-Details}\\
 & - subjects\\
 & - marks\\
 & - percentage\\
 & - aggregate\\
\hline
\end{tabular}
\end{center}

Now it’s pretty easy to keep track of each of the variables with the help of their
corresponding groups. Isn’t it? That’s exactly the idea behind the concepts of structure.

\subsection{Syntax}
\label{sec:org990101d}

In C Language, The syntax of writing a block of structure is follows:

\begin{verbatim}
struct <structure_name> {
  data_element#1;
  data_element#2;
  data_element#3;
    .
    .
    .
  data_element#n;
};
\end{verbatim}

Now, Let’s try to construct our very own structure in C Language for the
following sample:

\begin{center}
\begin{tabular}{ll}
\hline
\uline{GROUP - A} & \textbf{student-Personal-Details}\\
\hline
 & - name\\
 & - age\\
 & - gender\\
 & - DOB\\
 & - email\\
 & - mobile\\
 & - father-Name\\
 & - mother-name\\
\hline
\end{tabular}
\end{center}

becomes:

\begin{verbatim}
struct student_Personal_Details {
  char *name;
  int age;
  char gender;
  int DOB;
  char *email;
  int mobile;
  char father_Name;
  char mother_Name;
};
\end{verbatim}

\subsection{Properties of a structure}
\label{sec:org54d5535}

\begin{itemize}
\item Structure in itself is user-defined data-type.
\item The \texttt{<structure\_name>} is a pointer, pointing the first data-element of
it’s collection.
\item All the data-elements of a structure are stored in a contiguous memory fashion
i.e in above example, if \texttt{student\_Personal\_Details} is a structure name then it would
point/store the address of it’s first element: \texttt{char *name;}. We’ll later
explore how it works internally.
\item A structure can hold as many data-elements as required and that too
heterogeneous elements (different data-type).
\item Structures are defined globally.
\item All data-elements of a structure are private/only known to structure and
it’s variables. They can’t be directly accessed outside the structure.
\item The data-elements in a structure are called \texttt{members} of that structure.
\item Structures and it’s members are accessed via their \texttt{structure variables} and the
\texttt{DOT (.)} operator i.e.
\end{itemize}

\subsection{Structure variables}
\label{sec:orgfee4e9f}

As we discussed earlier, \texttt{structure} itself is a user-defined data-type. So,
every data-type must’ve a variable-name so as to use it. In case of
\texttt{structures}, they are declared as follows:

\begin{verbatim}
struct <structure_name> <structure_variable>; 
\end{verbatim}

For example:

\begin{verbatim}
struct student_Personal_Details std1;
\end{verbatim}

So, \texttt{std1} is a variable name of \texttt{struct student\_Personal\_Details} data-type.

\section{A basic Students Record program}
\label{sec:org12c8106}

Now, Let’s try to develop a program where our goal is to get the following data
of a student from the user:

\begin{itemize}
\item Roll No
\item Name
\item Email
\item Branch
\end{itemize}

\subsection{using standard approach}
\label{sec:org7319734}

Writing ’Students Record’ program using only single main/normal function.

\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

int main (void) {
  int rollNo;
  char *name;
  char *email;
  char *branch;

  printf("Roll No - ");
  scanf(”%d“, &rollNo);

  printf("Name - ");
  fgets(&name, 25, stdin);

  printf("Branch - ");
  fgets(&branch, 10, stdin);

  printf("Email - ");
  fgets(&email, 50, stdin);

  return EXIT_SUCCESS;
}
\end{verbatim}

\subsection{using structural approach}
\label{sec:orge4130e9}

Same program, but instead using structure.

\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

struct student_Personal_Details {
  int rollNo;
  char *name;
  char *email;
  char *branch;
};

struct student_Personal_Details std1;

void populate_Structure(void) {
  printf("Roll No. - ");
  scanf(”%d“, &std1.rollNo);

  printf("Name - ");
  fgets(&name, 25, std1.stdin);

  printf("Branch - ");
  fgets(&branch, 10, std1.stdin);

  printf("Email - ");
  fgets(&email, 50, std1.stdin);
}

int main (void) {
  populate_Structure();

  return EXIT_SUCCESS;
}
\end{verbatim}

\subsection{using structure with ’typedef’}
\label{sec:org7c06ca9}

The \texttt{typedef} stands for \texttt{type definition}. So using \texttt{typedef}, we can give a
new alias/name to already existing data-type i.e. same as one person can have
two names.

\subsubsection{Syntax:}
\label{sec:org5021de9}

\begin{verbatim}
typedef <datatype> <alias/new_name>;
\end{verbatim}

\subsubsection{Example:}
\label{sec:org95cad00}

Instead of writing:

\begin{verbatim}
struct student_Personal_Details std1;
struct student_Personal_Details std2;
struct student_Personal_Details std3;
\end{verbatim}

We can take create our own data-type using \texttt{typedef} as follows:

\begin{verbatim}
typedef struct student_Personal_Details stdRecord;

stdRecord std1;
stdRecord std2;
stdRecord std3;
\end{verbatim}

So, finally the program becomes:

\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

struct student_Personal_Details {
  int rollNo;
  char *name;
  char *email;
  char *branch;
};

typedef student_Personal_Details stdRecord;
stdRecord std1;

void populate_Structure(void) {
  printf("Roll No. - ");
  scanf(”%d“, &std1.rollNo);

  printf("Name - ");
  fgets(&name, 25, std1.stdin);

  printf("Branch - ");
  fgets(&branch, 10, std1.stdin);

  printf("Email - ");
  fgets(&email, 50, std1.stdin);
}

int main (void) {
  populate_Structure();

  return EXIT_SUCCESS;
}
\end{verbatim}

\section{Thank You!}
\label{sec:org671cb5e}

[Description] - Coming soon…
\end{document}
