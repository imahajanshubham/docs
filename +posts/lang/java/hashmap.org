#+TITLE: Hash Maps in Java

<<<<<<< HEAD
#+ATTR_HTML: :width 100% class="center"
| Home | Featured Blogs | [[https://github.com/imahajanshubham][GitHub]] |
=======
#+SETUPFILE: ../../../+themes/readtheorg.setup
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755

* Table of Contents                                       :TOC_4_gh:noexport:
- [[#basics-of-hash-maps][Basics of Hash Maps]]
  - [[#definition][Definition]]
    - [[#but-what-do-we-mean-by-that][But what do we mean by that?]]
    - [[#what-did-we-observed][What did we observed?]]
<<<<<<< HEAD
=======
    - [[#what-did-we-observed-1][What did we observed?]]
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
- [[#syntax][Syntax]]
- [[#properties-of-a-hashmap][Properties of a HashMap]]
- [[#a-sample-program][A sample program]]
- [[#the-test-case][The test case]]
- [[#a-humble-solution][A humble solution]]
  - [[#step---1][Step - 1]]
  - [[#step---2][Step - 2]]
  - [[#step---3][Step - 3]]
  - [[#step---4][Step - 4]]
  - [[#step---5][Step - 5]]
<<<<<<< HEAD
  - [[#step---6][Step - 6]]
- [[#thank-you][Thank You!]]

* DONE Basics of Hash Maps

** Definition

Java HashMap is one of the most popular Collection classes in java. Java Hash is Hash table based implementation. HashMap in java extends AbstractMap class
that implement(setq org-hide-emphasis-markers t)  printf("Hello World!\n");
s Map interface.

*** But what do we mean by that?

=======
  - [[#step---5-1][Step - 5]]
  - [[#step---6][Step - 6]]
- [[#thank-you][Thank You!]]

* Basics of Hash Maps
** Definition
Java HashMap is one of the most popular Collection classes in java. Java Hash is
Hash table based implementation. HashMap in java extends AbstractMap class that
implements Map interface.

*** But what do we mean by that?
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
Before trying to understand the definition of Hash Map, we should try to understand
the concept behind the Hash Map.

Let’s say we want make a record of a phone-book (person’s name and phone no) as
follows:

<<<<<<< HEAD
#+BEGIN_NOTE
=======
|--------+------------|
| *Name*   |  *Phone No.* |
|--------+------------|
| Raj    | 2345671001 |
| Nisha  | 4464832994 |
| Sonu   | 4858830685 |
| Nitin  | 8739111330 |
| Akshay | 8743193003 |
| Muskan | 9899363086 |
|--------+------------|

#+begin_note
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
For the sake of simplicity (to avoid rehashing), let’s assume:

- Each name is unique.
- A single person can have only one phone no.
<<<<<<< HEAD
#+END_NOTE

| *Name* | *Phone No.* |
|--------+-------------|
| Raj    |  2345671001 |
| Nisha  |  4464832994 |
| Sonu   |  4858830685 |
| Nitin  |  8739111330 |
| Akshay |  8743193003 |
| Muskan |  9899363086 |
=======
#+end_note

| *Name*   |  *Phone No.* |
|--------+------------|
| Raj    | 2345671001 |
| Nisha  | 4464832994 |
| Sonu   | 4858830685 |
| Nitin  | 8739111330 |
| Akshay | 8743193003 |
| Muskan | 9899363086 |
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755

and so on…

Now what we want to do is:
If we say a name, we wanna know his/her phone no.

For ex:

<<<<<<< HEAD
| Input  |        Raj |
| Output | 2345671001 |

*** What did we observed?

=======
|--------+------------|
| Input  |        Raj |
| Output | 2345671001 |
|--------+------------|

*** What did we observed?
- We don’t know the exact no of names/phone-nos.
- So the Hash-Size is not fixed. But there are ways via which we can fix the
  Hash-Size (using constructors).
- The order of the entries (Raj -> Nisha or Nisha -> Raj) doesn’t matter for us
  to fetch their phone nos. So Hash Map doesn’t require sorted input.
- Person’s name (input) is the ~KEY~ to find the ~VALUE~ i.e. phone no. (output) i.e
  *name is mapped with phone no*.
- Instead of phone record, we can create any type of record. So the data-type of
  Keys/Values depends upon the user.

| Input  |        Raj |
| Output | 2345671001 |

*** What did we observed?
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
- We don’t know the exact no of names/phone-nos.

#+begin_tip
The no of entries (name/phone no) in the Hash Map is called *Hash-Size*.
#+end_tip

So the Hash-Size is not fixed. But there are ways via which we can fix the
Hash-Size (using constructors).

- The order of the entries (Raj -> Nisha or Nisha -> Raj) doesn’t matter for us
  to fetch their phone nos. So Hash Map doesn’t require sorted input.
- Person’s name (input) is the ~KEY~ to find the ~VALUE~ i.e. phone no. (output)
  i.e *name is mapped with phone no*.
- Instead of phone record, we can create any type of record. So the data-type of
  Keys/Values depends upon the user.
- Each ~Name - phone no~ is in the form of pair similar to ~Key - Value~.

Till know, we came to understand a little-bit about something known as
Hash-Size, Keys and Values. Now let’s try to understand more about Hash Map in
technical terms.

<<<<<<< HEAD
* DONE Syntax

=======
* Syntax
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
In Java, the HashMap class’ object is declared as follows:

#+begin_src java
Map<Key, Value> obj = new HashMap<Key, Value>();
#+end_src

For ex:

#+begin_src java
Map<String, Integer> record1 = new HashMap<String, Integer>();
Map<String, String> record2 = new HashMap<String, String>();
#+end_src

<<<<<<< HEAD
* TODO Properties of a HashMap

=======
* Properties of a HashMap
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
- HashMap is denoted as ~HashMap<Key, Value>~.
- No need to specify the size of HashMap.
- No need of sorted input.
- Neither it sorts the stored input.
- Similar to ~Hashtable~ class except it permits null values and keys.
- You need to import ~java.util.HashMap~ class in order to use the HashMap class
  and its methods.

<<<<<<< HEAD
#+begin_note
There are a lot many other important properties too such:
- Rehashing
- Load Factor
- Various methods.
  
But we will study all these and others during our lifelong journey ♥.
#+end_note

* DONE A sample program

=======
* A sample program
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
What better way to understand more than to learn it by implementation? With that
spirit, let’s try to make a program in java to implement a phonebook
as follows:

1) Get ’n’ (~INTEGER~ value) from the user, denoting the no of entries/records
   to be filled in the phonebook.
2) Now, get ’n’ no of names-phoneno (~STRING-INTEGER~) space separated pairs from the user.

   For ex:

  | Raj 34745910  |
  | Sonu 86988901 |
  | Ravi 87240393 |

3) Get unknown no of names (~STRING~) from the user and for each of the these
   names, print:

| If name is present in the phonebook | *name=phoneno* |
| If name is not present              | *Not found*    |

<<<<<<< HEAD
* DONE The test case

=======
* The test case
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
Input:

| 3             |
| Raj 34745910  |
| Sonu 86988901 |
| Ravi 87240393 |
| Raju          |
| Ravi          |

Output:

| Not found     |
| Ravi=87240393 |

<<<<<<< HEAD
* DONE A humble solution

** Step - 1

=======
* A humble solution
** Step - 1
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
Let’s create testMain class with main function and initialize ~Scanner~ and ~Map~
classes:

#+begin_src java
  import java.util.*;
  import java.io.*;

  class testMain {
    public static void main(String []args) {
      Map<String, Integer> phoneBook = new HashMap<String, Integer>();
      Scanner scan = new Scanner(System.in);
    }
  }    
#+end_src

** Step - 2
<<<<<<< HEAD

Now let’s get the value of ’n’ (~INTEGER~) i.e. the no of phone records to be entered:
=======
Now let’s get the value of ’n’ (~INTEGER~) i.e. the no of phone records to be
entered:
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755

#+begin_src java
  int n = scan.nextInt();
#+end_src

** Step - 3
<<<<<<< HEAD

Now let’s fill ’n’ records (~STRING INTEGER~) in the phonebook.

#+begin_src java
=======
Now let’s fill ’n’ records (~STRING-INTEGER~) in the phonebook.

#+begin_src java
  int n = scan.nextInt();
  
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
  for(int i = 0; i < n; i++){
    String name = scan.next();
    int phone = scan.nextInt();

    phoneBook.put(name, phone);
  }
#+end_src

#+begin_tip
To put the data (name, phoneno) in the HashMap/phonebook, ~put()~ method is used.

*Syntax:*
       ~put(Key, Value)~
#+end_tip

** Step - 4
<<<<<<< HEAD

=======
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
Now comes a little tricky part:

3. Get unknown no of names (~STRING~) from the user and for each of the these
   names, print:

| If name is present in the phonebook | *name=phoneno* |
| If name is not present              | *Not found*    |

Let’s to do it one-by-one:

- get unknown no of names (~STRING~).

#+begin_src java
<<<<<<< HEAD
while(scan.hasNext()) {
  String s = scan.next();
}
#+end_src

** Step - 5

=======
  while(scan.hasNext()) {
    String s = scan.next();
  }
#+end_src

** Step - 5
- print the required output.

#+begin_src java
  while (scan.hasNext()) {
    String s = scan.next();
    Integer phoneNumber = phoneBook.get(s);

    System.out.println((phoneNumber != null) ? s + "=" + phoneNumber
                                             : "Not found");
  }
#+end_src

** Step - 5
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
- print the required output.

#+begin_src java
while(scan.hasNext()) {
  String s = scan.next();
  Integer phoneNumber = phoneBook.get(s);
  
  System.out.println((phoneNumber != null) ? s + "=" + phoneNumber : "Not found");
}
#+end_src

#+begin_tip
To get the data (phone no) from the HashMap, ~get()~ method is used.

*Syntax:*
       ~get(Key)~

<<<<<<< HEAD
So, ~phoneBook.get(Raj)~ will return the phone no of ’Raj’ if he’s
present. To check whether a Name/Key is present in the ~HashMap~ or not, ~HashMap~ uses ~equals()~ method internally.
#+end_tip

** Step - 6

=======
So, ~phoneBook.get(Raj)~ will return the phone no of ’Raj’ if he’s present. To
check whether a Name/Key is present in the ~HashMap~ or not, ~HashMap~ uses ~equals()~
method internally.
#+end_tip

** Step - 6
>>>>>>> 089941baa3b144514581895c2c4fa2031cc34755
Let’s connect the dots:

#+begin_src java
  import java.util.*;
  import java.io.*;

  class testMain {
    public static void main(String []args) {
      Map<String, Integer> phoneBook = new HashMap<String, Integer>();
      Scanner scan = new Scanner(System.in);

      int n = scan.nextInt();

      for(int i = 0; i < n; i++) {
        String name = scan.next();
        int phone = scan.nextInt();

        phoneBook.put(name, phone);
      }

      while(scan.hasNext()) {
        String s = scan.next();
        Integer phoneNumber = phoneBook.get(s);

        System.out.println((phoneNumber != null) ? s + "=" + phoneNumber : "Not found");
      }

      scan.close();
    }
  }
#+end_src

That’s it, the program to implement HashMap Logic in Java. I hope if not all,
we learned something :)

* Thank You!
